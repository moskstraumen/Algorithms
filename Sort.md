# 排序算法
http://bubkoo.com/tags/algorithm/
##选择排序（Selection Sort）
* 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
* 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾
* 以此类推，直到所有元素均排序完毕。

选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的序列进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

##冒泡排序（Bubble Sort）
* 比较相邻的元素。如果第一个比第二个大，就交换他们两个
* 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数
* 针对所有的元素重复以上的步骤，除了最后一个
* 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较

##插入排序 (Insertion Sort)
* 从第一个元素开始，该元素可以认为已经被排序
* 取出下一个元素，在已经排序的元素序列中从后向前扫描
* 如果该元素（已排序）大于新元素，将该元素移到下一位置
* 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置
* 将新元素插入到该位置后
* 重复步骤 2~5

## 二分查找法
搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。

##桶排序 (Bucket Sort)
* 假设待排序的一组数统一的分布在一个范围中，并将这一范围划分成几个子范围，也就是桶
* 将待排序的一组数，分档规入这些子桶，并将桶中的数据进行排序
* 将各个桶中的数据有序的合并起来

##堆排序 (Heap Sort)

##快速排序 (Quick Sort)
* 在数据集之中，选择一个元素作为”基准”（pivot）。
* 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。
* 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。

##希尔排序 (Shell Sort)
* 先取一个正整数 d1(d1 < n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序
* 然后取 d2(d2 < d1)
* 重复上述分组和排序操作；直到取 di = 1(i >= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d1 约为 n/2，d2 为 d1 /2， d3 为 d2/2 ，…， di = 1。

## 归并排序 (Merge Sort)
* 把 n 个记录看成 n 个长度为 l 的有序子表
* 进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表
* 重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。